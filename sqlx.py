# sqlx 是一种扩展 sql 的语言
# 目标是打造 "易读易写 方便维护" 的 sql 脚本
# 语法参考 test.sqlx

import os
import sys
import re
import traceback
import pprint
import random
import copy


VERSION = '0.1.3'


# 构建后添加的头部文字
HEADER = '-- ======== Generated By Sqlx ========\n-- https://github.com/taojy123/sqlx'

# sqlx 语法注释标记
COMMENT_PREFIX = '-- !'

# 目前支持的关系运算符
OPERATORS = ['>', '<', '>=', '<=', '==', '!=']

# 定义转义符
ESCAPE = '\\'


def escape(content, escape_map=None):
    # 转义处理，先只传原文，语法处理后再次调用该函数，将第一次访问的 escape_map 传入
    if escape_map is None:
        escape_map = {}
        items = re.findall(r'\\\S', content)
        for item in items:
            value = item[1]
            # 如果出现重复随机数会出错，概率太低，不特殊处理了
            n = random.randint(1, 99999999)
            # 为兼容 python3.3 只能以 .format 方式代替 f''
            key = '[escape{n}]'.format(**locals())
            escape_map[key] = value
            content = content.replace(item, key)
        return content, escape_map
    else:
        assert isinstance(escape_map, dict)
        for key, value in escape_map.items():
            content = content.replace(key, value)
        return content
    

def remove_space_line(content):
    # 移除空行
    new_lines = []
    for line in content.splitlines():
        if line.strip():
            new_lines.append(line)
    return '\n'.join(new_lines)


def remove_gap(content, n):
    # 移除过多的空行 比如传入参数为 5 ,则会将文本中 5 个空行替换为 1 个空行
    target = '\n' * n
    while target in content:
        content = content.replace(target, '\n')
    return content

def get_indent(s):
    # 获取字符串前有多少个前导空格
    return len(s) - len(s.lstrip())


def render(content, define_map, block_map, local_map=None):
    # render sqlt content to sql

    key_map = {}
    key_map.update(define_map)
    if local_map:
        key_map.update(local_map) 

    # 处理 for 循环，暂时不支持嵌套
    for_blocks = re.findall(r'(\{\s*%\s*for\s+(.+?)\s+in\s+(.+?)\s*%\s*\}(.*?)\{\s*%\s*endfor\s*%\s*\})', content, re.S)
    for full_block, for_names, for_values, for_content in for_blocks:
        for_names = for_names.split('|')
        for_values = for_values.split(',')
        for_values = [t.split('|') for t in for_values]
        # {% for n|m in 1|a,2|b,3|c %} ... {% endfor %}
        # => 
        # for_names = ['n', 'm']
        # for_values = [['1', 'a'], ['2', 'b'], ['3', 'c']]
        rendered_blocks = []
        for values in for_values:
            local_map = {}
            local_map.update(key_map)
            for for_name, for_value in zip(for_names, values):
                local_map[for_name] = for_value
            # local_map => {n: 1, m: a}
            rendered_block = render(for_content, define_map, block_map, local_map)
            rendered_block = remove_space_line(rendered_block)
            rendered_blocks.append(rendered_block)

        rendered_blocks = '\n'.join(rendered_blocks)
        content = content.replace(full_block, rendered_blocks)

    # 处理 if 判断，暂时不支持嵌套
    if_blocks = re.findall(r'(\{\s*%\s*if(.+?)%\s*\}(.*?)\{\s*%\s*endif\s*%\s*\})', content, re.S)
    for full_block, condition, if_content in if_blocks:
        # {% if a > b %} ... {% else %} ... {% endif %}
        if_content = re.sub(r'\{\s*%\s*else\s*%\s*\}', r'{% else %}', if_content)
        ts = if_content.split(r'{% else %}')
        assert len(ts) in [1, 2], '{full_block} 内容编写错误!'.format(**locals())
        if_content = ts[0]
        if len(ts) == 2:
            else_content = ts[1]
        else:
            else_content = ''

        a1 = a2 = None
        for op in OPERATORS:
            if op in condition:
                assert condition.count(op) == 1, '{condition} 判定条件编写错误!'.format(**locals())
                a1, a2 = condition.split(op)
                a1 = a1.strip()
                a2 = a2.strip()
                break
        assert a1 and a2, '{condition} 未找到合法的关系运算符!'.format(**locals())

        # 判断项默认以字符串类型比较
        # 如果以 $ 开头后接变量名，则转为对应的变量值
        if a1.startswith('$') and a1[1:] in key_map:
            a1 = key_map[a1[1:]]

        if a2.startswith('$') and a2[1:] in key_map:
            a2 = key_map[a2[1:]]

        # 先尝试将两个变量转为数字类型再比较
        try:
            a1 = float(a1)
        except ValueError as e:
            pass
        try:
            a2 = float(a2)
        except ValueError as e:
            pass

        a1 = repr(a1)
        a2 = repr(a2)
        s = '{a1} {op} {a2}'.format(**locals())

        try:
            result = eval(s)
        except Exception as e:
            print(condition)
            print(s)
            raise e

        assert result in (True, False)

        if result:
            rendering_content = if_content
        else:
            rendering_content = else_content

        rendered_block = render(rendering_content, define_map, block_map, key_map)
        rendered_block = remove_space_line(rendered_block)
        content = content.replace(full_block, rendered_block)

    # 处理 define 替换和 block 替换
    tags = re.findall(r'\{.+?\}', content)
    tags = set(tags)
    rendered_map = {}
    for tag in tags:
        key = tag.strip('{}').strip()
        if '(' not in key:
            assert key in key_map, '`{tag}` define 引用未找到!'.format(**locals())
            value = key_map[key]
            # 对于简单的变量替换，直接 replace 就行了
            content = content.replace(tag, value)
        else:
            rs = re.findall(r'(.+?)\((.*?)\)', key)
            assert len(rs) == 1, '`{tag}` block 引用语法不正确!'.format(**locals())
            block_name, params = rs[0]
            assert block_name in block_map, '`{tag}` block 引用未找到!'.format(**locals())
            block_content = block_map[block_name]['content']
            param_names = block_map[block_name]['params']
            params = params.split(',')
            params = [param.strip() for param in params if param.strip()]
            assert len(param_names) == len(params), '{tag} block 参数数量不正确!'.format(**locals())
            local_map = copy.copy(key_map)
            for name, value in zip(param_names, params):
                if value.startswith('$') and value[1:] in key_map:
                    value = key_map[value[1:]]
                local_map[name] = value
            rendered_block = render(block_content, define_map, block_map, local_map)
            # 对于块替换，为了更好的视觉体验，先将渲染后的块内容保存下来，接下来用到
            rendered_map[tag] = rendered_block

    lines = content.splitlines()
    new_lines = []
    for line in lines:
        for tag in rendered_map.keys():
            if tag in line:
                # 遍历每一行，替换行中的块内容，并加上合适的缩进
                # 例如 `select * from {myblock()} where 1=1` 渲染后得到:
                # select * from 
                #     (
                #         SELECT
                #             id, name
                #         FROM
                #             mytable
                #     ) AS myblock
                # where 1=1
                n = get_indent(line)
                rendered_block = rendered_map[tag]
                rendered_block = rendered_block.replace('\n', '\n' + ' ' * n)
                rendered_block = '\n' + ' ' * n + rendered_block + '\n' + ' ' * n
                # 先尝试替换 tag 两边有空格的情况
                tag2 = ' {tag} '.format(**locals())
                line = line.replace(tag2 , rendered_block)
                line = line.replace(tag, rendered_block)
        new_lines.append(line)
    content = '\n'.join(new_lines)

    return content


def handle_import(content, path, define_map, block_map):
    # 处理 import 和 sqlx 注释
    # 通过 import 可以引入现有的 sqlx 脚本文件作，但只能导入其中的 define 和 block
    # 如果在当前脚本有重复同名变量或 block，会被覆盖以当前脚本为准
    # import xxx

    assert isinstance(define_map, dict)
    assert isinstance(block_map, dict)
    if not path:
        path = os.getcwd()
    assert os.path.isdir(path), '{path} 脚本所在目录不正确!'.format(**locals())

    # 插入第一行空行
    new_lines = ['']
    lines = content.splitlines()
    for line in lines:

        if line.startswith(COMMENT_PREFIX):
            continue

        if COMMENT_PREFIX in line:
            i = line.find(COMMENT_PREFIX)
            line = line[:i]

        if line.lower().startswith('import '):
            items = line.split()
            assert len(items) == 2, '`{line}` import 语法不正确!'.format(**locals())
            define, script_name = items
            script_name += '.sqlx'
            script_path = os.path.join(path, script_name)
            assert os.path.isfile(script_path), '{script_path} 导入模块路径不正确!'.format(**locals())
            
            script_content = open(script_path, encoding='utf8').read()
            script_content = handle_import(script_content, path, define_map, block_map)
            script_content = handle_define(script_content, define_map)
            script_content = handle_block(script_content, block_map)

            continue

        new_lines.append(line)

    sqlx_content = '\n'.join(new_lines)

    # pprint.pprint(define_map)
    # pprint.pprint(block_map)
    return sqlx_content


def handle_define(content, define_map):
    # 处理 define
    # define a xxx
    assert isinstance(define_map, dict)
    new_lines = []
    lines = content.splitlines()
    for line in lines:
        if line.lower().startswith('define '):
            line = line.replace('=', ' ')  # 兼容 define a = xxx 写法
            items = line.split()
            assert len(items) == 3, '`{line}` define 语法不正确!'.format(**locals())
            define, key, value = items
            define_map[key] = value
            continue
        new_lines.append(line)
        
    sqlx_content = '\n'.join(new_lines)

    # pprint.pprint(define_map)
    return sqlx_content


def handle_block(content, block_map):
    assert isinstance(block_map, dict)
    # 处理 block
    # block foo()
    #   ...
    # endblock
    block_pattern = r'\nblock\s+(.+?)\((.*?)\)[:\s]*\n(.*?)\nendblock'  # 兼容 block foo(): 写法
    blocks = re.findall(block_pattern, content, re.S)
    content = re.sub(block_pattern, '', content, flags=re.S)
    for block in blocks:
        block_name, params, block_content = block
        params = params.split(',')
        params = [param.strip() for param in params if param.strip()]
        block_map[block_name] = {
            'params': params,
            'content': block_content,
        }
    # pprint.pprint(block_map)
    return content


def build(content, pretty=False, path=''):
    # build sqlx content to sql
    
    content, escape_map = escape(content)
    
    define_map = {}
    block_map = {}

    content = handle_import(content, path, define_map, block_map)
    content = handle_define(content, define_map)
    content = handle_block(content, block_map)

    sql = render(content, define_map, block_map)
    sql = sql.strip()
    sql = escape(sql, escape_map)
    sql = remove_gap(sql, 5)
    header = HEADER
    sql = '{header}\n\n{sql}\n'.format(**locals())

    # print(sql)

    if pretty:
        import sqlformat
        sql = sqlformat.sqlformat(sql)

    return sql


def auto(path='.', pretty=False):

    import pyperclip
    
    # pip intall sqlx
    # sqlx [path/to/sqlxfiles]
    version = VERSION
    print('==== sqlx v{version} ===='.format(**locals()))

    args = sys.argv
    if len(args) > 1:
        path = args[1]

    if 'pretty' in args:
        pretty = True

    if os.path.isdir(path):
        files = os.listdir(path)
        files = [file for file in files if file.endswith('.sqlx')]
    elif os.path.isfile(path) and path.endswith('.sqlx'):
        files = [path]
    else:
        print('Usage: sqlx path/to/sqlxfiles')
        return 1

    for file in files:
        # build xx.sqlx to dist/xx.sql

        print('building', file)

        # sqlx 脚本所在目录
        dirname, filename = os.path.split(file)
        
        # 要生成的 sql 所在目录
        distname = os.path.join(dirname, 'dist')
        
        # 要生成的 sql 文件路径
        filename = os.path.join(distname, filename[:-1])

        if not os.path.isdir(distname):
            os.makedirs(distname)

        sqlx_content = ''
        for encoding in ['utf8', 'gbk']:
            try:
                sqlx_content = open(file, encoding=encoding).read()
                break
            except Exception as e:
                encoding = None
                
        if not encoding:
            print(file, 'read failed!')
            continue

        sql_content = build(sqlx_content, pretty, dirname)
        copied = ''
        if os.path.isfile(filename):
            old_content = open(filename, encoding=encoding).read()
            if sql_content != old_content:
                pyperclip.copy(sql_content)
                copied = 'and Copied'
        else:
            pyperclip.copy(sql_content)
            copied = 'and Copied'
        open(filename, 'w', encoding=encoding).write(sql_content)
        print('{filename} Built {copied}'.format(**locals()))


if __name__ == '__main__':
    try:
        auto()
    except:
        traceback.print_exc()
        print('See https://github.com/taojy123/sqlx/blob/master/README.md for help')
    input('Press Enter to Exit..')

